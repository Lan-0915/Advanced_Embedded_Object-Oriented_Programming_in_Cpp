#include "timebase.h"
#include "stm32f4xx.h"

#define CTRL_ENABLE		(1U<<0)
#define CTRL_TICKINT	(1U<<1)
#define CTRL_CLCKSRC	(1U<<2)
#define CTRL_COUNTFLAG	(1U<<16)

#define ONE_SEC_LOAD	16000000

#define MAX_DELAY		0xFFFFFFFF

#define TICK_FREQ		1


volatile uint32_t g_curr_tick;
volatile uint32_t g_curr_tick_p;



/**
 * 延迟1s
 * */
void delay(uint32_t delay) {
	uint32_t tickstart = get_tick();
	uint32_t wait = delay;

	if (wait < MAX_DELAY) {
		wait += (uint32_t)TICK_FREQ;
	}

	while ((get_tick() - tickstart) < wait) {}
}


uint32_t get_tick(void) {
	__disable_irq();
	g_curr_tick_p = g_curr_tick;
	__disable_irq();

	return g_curr_tick_p;
}


static void tick_increment(void) {
	g_curr_tick += TICK_FREQ;
}




/**
 * 时间基准初始化函数
 * */
void timebase_init(void) {

	/**
	 * 初始化 systick 的步骤
	 * */

	// 1. 禁用全局中断
	__disable_irq();

	// 2. 用每秒的时钟周期数来加载计时器
	SysTick->LOAD = ONE_SEC_LOAD - 1;

	// 3. 清除 systick 当前值寄存器
	SysTick->VAL = 0;

	// 4. 选择内部时钟源
	SysTick->CTRL = CTRL_CLCKSRC;

	// 5. 启用中断
	SysTick->CTRL |= CTRL_TICKINT;

	// 6. 启用 systick
	SysTick->CTRL |= CTRL_ENABLE;

	// 7. 启用全局中断
	__enable_irq();
}



void SysTick_Handler(void) {
	tick_increment();
}






