#include "spi.h"
#include "stddef.h"

#define GPIOAEN		(1U<<0)
#define SPI1EN		(1U<<12)


void spi1_gpio_init(void) {
	// 启用对 GPIOA 的时钟访问
	RCC->AHB1ENR |= GPIOAEN;

	// 设置 PA5 PA6 PA7 模式为交替功能模式
	// PA5
	GPIOA->MODER &=~(1U<<10);
	GPIOA->MODER |=(1U<<11);
	// PA6
	GPIOA->MODER &=~(1U<<12);
	GPIOA->MODER |=(1U<<13);
	// PA7
	GPIOA->MODER &=~(1U<<14);
	GPIOA->MODER |=(1U<<15);


	// 设置 PA5 PA6 PA7 的交替功能类型输入为 SPI1
	// PA5
	GPIOA->AFR[0] |=(1U<<20);
	GPIOA->AFR[0] &=~(1U<<21);
	GPIOA->AFR[0] |=(1U<<22);
	GPIOA->AFR[0] &=~(1U<<23);
	// PA6
	GPIOA->AFR[0] |=(1U<<24);
	GPIOA->AFR[0] &=~(1U<<25);
	GPIOA->AFR[0] |=(1U<<26);
	GPIOA->AFR[0] &=~(1U<<27);
	// PA7
	GPIOA->AFR[0] |=(1U<<28);
	GPIOA->AFR[0] &=~(1U<<29);
	GPIOA->AFR[0] |=(1U<<30);
	GPIOA->AFR[0] &=~(1U<<31);


	// 启用对 SPI1 的时钟访问
	RCC->AHB1ENR |= SPI1EN;
}



StatusTypeDef spi_init(SPI_HandleTypeDef *hspi) {
	// 检查 SPI 句柄分配是否不为空
	if (hspi == NULL) {
		return DEV_ERROR;
	}

	// 禁用 CRC 计算
	hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	if (hspi->State == SPI_STATE_RESET) {
		spi1_gpio_init();
	}

	// hspi 状态忙
	hspi->State = SPI_STATE_BUSY;

	// 禁用 SPI
	CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_SPE);

	// 控制寄存器1 (CR1) 的配置
	WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
									(hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
									(hspi->Init.DataSize & SPI_CR1_DFF) |
									(hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
									(hspi->Init.CLKPhase & SPI_CR1_CPHA) |
									(hspi->Init.NSS & SPI_CR1_SSM) |
									(hspi->Init.BuadRatePrescaler & SPI_CR1_BR_Msk) |
									(hspi->Init.FirstBit & SPI_CR1_LSBFIRST) |
									(hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

	// 控制寄存器2 (CR2) 的配置
	WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));

	hspi->ErrorCode = SPI_ERROR_NONE;
	hspi->State = SPI_STATE_READY;

	return DEV_OK;

}



StatusTypeDef spi_transmit(SPI_HandleTypeDef *hspi, uint8_t *p_data, uint16_t size, uint32_t timeout) {
	uint32_t tickstart;
	StatusTypeDef error_code = DEV_OK;
	uint16_t tx_xfer_cnt;

	tx_xfer_cnt = size;
	tickstart = get_tick();

	if (hspi->State != SPI_STATE_READY) {
		error_code = DEV_BUSY;
		hspi->State = SPI_STATE_READY;
		return error_code;
	}

	if ((p_data == NULL) || (size == 0)) {
		error_code = DEV_ERROR;
		hspi->State = SPI_STATE_READY;
		return error_code;
	}

	// 设置事务信息
	hspi->State = SPI_STATE_BUSY_TX;
	hspi->ErrorCode = SPI_ERROR_NONE;
	hspi->pTxBuffPtr = (uint8_t *)p_data;
	hspi->TxXferSize = size;
	hspi->TxXferCount = size;
	hspi->pRxBuffPtr = (uint8_t *)NULL;
	hspi->RxXferSize = 0;
	hspi->RxXferCount = 0;


	// 配置通信方向
	if (hspi->Init.Direction == SPI_DIRECTION_1LINE) {
		CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_SPE);

		// 设置一条 TX 线路
		SET_BIT(hspi->Instance->CR1, SPI_CR1_BIDIOE);
	}


	// 检查 SPI 是否启用, 若未启用则启用
	if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE) {
		SET_BIT(hspi->Instance->CR1, SPI_CR1_SPE);
	}


	// 以 16 bit 模式发送数据
	if (hspi->Init.DataSize == SPI_DATASIZE_16BIT) {
		if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (tx_xfer_cnt == 1)) {
			hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
			hspi->pTxBuffPtr += sizeof(uint16_t);
			hspi->TxXferCount--;
		}
		while (hspi->TxXferCount > 0) {
			// 检查 TXE 标志是否已设置, 然后发送数据
			if (hspi->Instance->SR & (SPI_FLAG_TXE)) {
				hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
				hspi->pTxBuffPtr += sizeof(uint16_t);
				hspi->TxXferCount--;
			} else {
				if ((((get_tick() - tickstart) >= timeout) && (timeout != MAX_DELAY)) || (timeout == 0)) {
					error_code = DEV_TIMEOUT;
					hspi->State = SPI_STATE_READY;
					return error_code;
				}
			}
		}
	}

	// 以 8 bit 模式发送数据
	else {
		if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (tx_xfer_cnt == 1)) {
			*((__IO uint8_t *)hspi->Instance->DR) = *hspi->pTxBuffPtr;
			hspi->pTxBuffPtr += sizeof(uint8_t);
			hspi->TxXferCount--;
		}
		while (hspi->TxXferCount > 0) {
			// 检查 TXE 标志是否已设置, 然后发送数据
			if (hspi->Instance->SR & (SPI_FLAG_TXE)) {
				*((__IO uint8_t *)hspi->Instance->DR) = *hspi->pTxBuffPtr;
				hspi->pTxBuffPtr += sizeof(uint8_t);
				hspi->TxXferCount--;
			} else {
				if ((((get_tick() - tickstart) >= timeout) && (timeout != MAX_DELAY)) || (timeout == 0)) {
					error_code = DEV_TIMEOUT;
					hspi->State = SPI_STATE_READY;
					return error_code;
				}
			}
		}
	}


	if (hspi->ErrorCode != SPI_ERROR_NONE) {
		error_code = DEV_ERROR;
	}

	hspi->State = SPI_STATE_READY;

	return error_code;
}




StatusTypeDef spi_receive(SPI_HandleTypeDef *hspi, uint8_t *p_data, uint16_t size, uint32_t timeout) {
	uint32_t tickstart;
	StatusTypeDef error_code = DEV_OK;

	tickstart = get_tick();

	if (hspi->State != SPI_STATE_READY) {
		error_code = DEV_BUSY;
		hspi->State = SPI_STATE_READY;
		return error_code;
	}

	if ((p_data == NULL) || (size == 0)) {
		error_code = DEV_ERROR;
		hspi->State = SPI_STATE_READY;
		return error_code;
	}

	// 设置事务信息
	hspi->State = SPI_STATE_BUSY_RX;
	hspi->ErrorCode = SPI_ERROR_NONE;
	hspi->pTxBuffPtr = (uint8_t *)NULL;
	hspi->TxXferSize = 0;
	hspi->TxXferCount = 0;
	hspi->pRxBuffPtr = (uint8_t *)p_data;
	hspi->RxXferSize = size;
	hspi->RxXferCount = size;


	// 检查 SPI 是否启用, 若未启用则启用
	if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE) {
		SET_BIT(hspi->Instance->CR1, SPI_CR1_SPE);
	}


	// 以 16 bit 模式接收数据
	if (hspi->Init.DataSize == SPI_DATASIZE_16BIT) {
		while (hspi->RxXferCount > 0) {
			// 检查 RXNE 标志是否已设置, 然后接受数据
			if (hspi->Instance->SR & (SPI_FLAG_RXNE)) {
				*(uint16_t *)hspi->pRxBuffPtr = *(__IO uint16_t *)&hspi->Instance->DR;
				hspi->pRxBuffPtr += sizeof(uint16_t);
				hspi->RxXferCount--;
			} else {
				if ((((get_tick() - tickstart) >= timeout) && (timeout != MAX_DELAY)) || (timeout == 0)) {
					error_code = DEV_TIMEOUT;
					hspi->State = SPI_STATE_READY;
					return error_code;
				}
			}
		}
	}

	// 以 8 bit 模式接收数据
	else {
		while (hspi->RxXferCount > 0) {
			// 检查 RXNE 标志是否已设置, 然后接受数据
			if (hspi->Instance->SR & (SPI_FLAG_RXNE)) {
				*(uint8_t *)hspi->pRxBuffPtr = *(__IO uint8_t *)&hspi->Instance->DR;
				hspi->pRxBuffPtr += sizeof(uint8_t);
				hspi->RxXferCount--;
			} else {
				if ((((get_tick() - tickstart) >= timeout) && (timeout != MAX_DELAY)) || (timeout == 0)) {
					error_code = DEV_TIMEOUT;
					hspi->State = SPI_STATE_READY;
					return error_code;
				}
			}
		}
	}


	if (hspi->ErrorCode != SPI_ERROR_NONE) {
		error_code = DEV_ERROR;
	}

	hspi->State = SPI_STATE_READY;

	return error_code;
}






