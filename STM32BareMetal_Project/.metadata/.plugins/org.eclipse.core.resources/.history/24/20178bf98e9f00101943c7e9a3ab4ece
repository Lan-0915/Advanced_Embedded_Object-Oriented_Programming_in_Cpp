#include "spi.h"


#define GPIOAEN		(1U<<0)
#define SPI1EN		(1U<<12)


void spi1_gpio_init(void) {
	// 启用对 GPIOA 的时钟访问
	RCC->AHB1ENR |= GPIOAEN;

	// 设置 PA5 PA6 PA7 模式为交替功能模式
	// PA5
	GPIOA->MODER &=~(1U<<10);
	GPIOA->MODER |=(1U<<11);
	// PA6
	GPIOA->MODER &=~(1U<<12);
	GPIOA->MODER |=(1U<<13);
	// PA7
	GPIOA->MODER &=~(1U<<17);
	GPIOA->MODER |=(1U<<15);


	// 设置 PA5 PA6 PA7 的交替功能类型输入为 SPI1
	// PA5
	GPIOA->AFR[0] |=(1U<<20);
	GPIOA->AFR[0] &=~(1U<<21);
	GPIOA->AFR[0] |=(1U<<22);
	GPIOA->AFR[0] &=~(1U<<23);
	// PA6
	GPIOA->AFR[0] |=(1U<<24);
	GPIOA->AFR[0] &=~(1U<<25);
	GPIOA->AFR[0] |=(1U<<26);
	GPIOA->AFR[0] &=~(1U<<27);
	// PA7
	GPIOA->AFR[0] |=(1U<<28);
	GPIOA->AFR[0] &=~(1U<<29);
	GPIOA->AFR[0] |=(1U<<30);
	GPIOA->AFR[0] &=~(1U<<31);


	// 启用对 SPI1 的时钟访问
	RCC->AHB1ENR |= SPI1EN;
}


StatusTypeDef spi_init(SPI_HandleTypeDef *hspi) {
	// 检查 SPI 句柄分配是否不为空
	if (hspi == NULL) {
		return DEV_ERROR;
	}

	// 禁用 CRC 计算
	hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	if (hspi->State == SPI_STATE_RESET) {
		spi1_gpio_init();
	}

	// hspi 状态忙
	hspi->State = SPI_STATE_BUSY;

	// 禁用 SPI
	CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_SPE);

	// 控制寄存器1 (CR1) 的配置
	WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
									(hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
									(hspi->Init.DataSize & SPI_CR1_DFF) |
									(hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
									(hspi->Init.CLKPhase & SPI_CR1_CPHA) |
									(hspi->Init.NSS & SPI CR1 SSM) |
									(hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
									(hspi->Init.FirstBit & SPI_CR1_LSBFIRST) |
									(hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

	// 控制寄存器2 (CR2) 的配置
	WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));

	hspi->ErrorCode = SPI_ERROR_NONE;
	HSPI->State = SPI_STATE_READY;

	return DEV_OK;

}


StatusTypeDef spi_transmit(SPI_HandleTypeDef *hspi, uint8_t *p_data, uint16_t size, uint32_t timeout) {
	uint32_t tickstart;
	StatusTypeDef error_code = DEV_OK;
	uint16_t tx_xfer_cnt;

	if (hspi->State != SPI_STATE_READY) {
		error_code = DEV_BUSY;
		hspi_State = Spi_STATE_READY;
		return error_code;
	}

	if ((p_data == NULL) || (size == 0)) {
		error_code = DEV_ERROR;
		hspi_State = Spi_STATE_READY;
		return error_code;
	}

	// 设置事务信息
	hspi->State = SPI_STATE_BUSY_TX;
	hspi->ErrorCode = SPI_ERROR_NONE;
	hspi->pTxBuffPtr = (uint8_t *)p_data;
	hspi->TxXferSize = size;
	hspi->TxXferCount = size;

	hspi->pRxBuffPtr = (uint8_t *)NULL;
	hspi->RxXferSize = 0;
	hspi->RxXferCount = 0;


	// 配置通信方向
	if (hspi->Init.Direction == SPI_DIRECTION_1LINE) {
		CLEAR_BIT(SPI1->CR1);
	}
}







